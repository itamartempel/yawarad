// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "yawarad": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/itamartempel/yawarad/design
// --out=$(GOPATH)/src/github.com/itamartempel/yawarad
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
)

// CreateBranchClusterBranchingContext provides the cluster-branching create-branch action context.
type CreateBranchClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateBranchPayload
}

// NewCreateBranchClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller create-branch action.
func NewCreateBranchClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateBranchClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateBranchClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateBranchClusterBranchingContext) Created(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateBranchClusterBranchingContext) BadRequest() error {
	ctx.ResponseData.WriteHeader(400)
	return nil
}

// UnprocessableEntity sends a HTTP response with status code 422.
func (ctx *CreateBranchClusterBranchingContext) UnprocessableEntity() error {
	ctx.ResponseData.WriteHeader(422)
	return nil
}

// ListBranchesClusterBranchingContext provides the cluster-branching list-branches action context.
type ListBranchesClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	Status      *string
	Team        *string
	ToTime      *int
	Type        *string
}

// NewListBranchesClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-branches action.
func NewListBranchesClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListBranchesClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListBranchesClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp2 := fromTime
			tmp1 := &tmp2
			rctx.FromTime = tmp1
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp5 := skip
			tmp4 := &tmp5
			rctx.Skip = tmp4
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp7 := toTime
			tmp6 := &tmp7
			rctx.ToTime = tmp6
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListBranchesClusterBranchingContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ListClusterBranchesClusterBranchingContext provides the cluster-branching list-cluster-branches action context.
type ListClusterBranchesClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	Status      *string
	Team        *string
	ToTime      *int
	Type        *string
}

// NewListClusterBranchesClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-cluster-branches action.
func NewListClusterBranchesClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClusterBranchesClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClusterBranchesClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp9 := fromTime
			tmp8 := &tmp9
			rctx.FromTime = tmp8
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp12 := skip
			tmp11 := &tmp12
			rctx.Skip = tmp11
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp14 := toTime
			tmp13 := &tmp14
			rctx.ToTime = tmp13
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClusterBranchesClusterBranchingContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListClusterBranchesClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListClusterSnapshotsClusterBranchingContext provides the cluster-branching list-cluster-snapshots action context.
type ListClusterSnapshotsClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
	FromTime    *int
	Limit       int
	Skip        *int
	ToTime      *int
}

// NewListClusterSnapshotsClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-cluster-snapshots action.
func NewListClusterSnapshotsClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClusterSnapshotsClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClusterSnapshotsClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp16 := fromTime
			tmp15 := &tmp16
			rctx.FromTime = tmp15
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp19 := skip
			tmp18 := &tmp19
			rctx.Skip = tmp18
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp21 := toTime
			tmp20 := &tmp21
			rctx.ToTime = tmp20
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClusterSnapshotsClusterBranchingContext) OK(r *CountableCollectionClusterSnapshots) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-snapshots+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListClusterSnapshotsClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListClustersClusterBranchingContext provides the cluster-branching list-clusters action context.
type ListClustersClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	ClusterType *string
	Limit       int
	Skip        *int
}

// NewListClustersClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-clusters action.
func NewListClustersClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClustersClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClustersClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramClusterType := req.Params["cluster_type"]
	if len(paramClusterType) > 0 {
		rawClusterType := paramClusterType[0]
		rctx.ClusterType = &rawClusterType
		if rctx.ClusterType != nil {
			if !(*rctx.ClusterType == "mysql" || *rctx.ClusterType == "mongodb") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`cluster_type`, *rctx.ClusterType, []interface{}{"mysql", "mongodb"}))
			}
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp24 := skip
			tmp23 := &tmp24
			rctx.Skip = tmp23
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClustersClusterBranchingContext) OK(r *CountableCollectionClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ListRequestTasksClusterBranchingContext provides the cluster-branching list-request-tasks action context.
type ListRequestTasksClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewListRequestTasksClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-request-tasks action.
func NewListRequestTasksClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListRequestTasksClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListRequestTasksClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListRequestTasksClusterBranchingContext) OK(r BranchRequestTaskCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json; type=collection")
	}
	if r == nil {
		r = BranchRequestTaskCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ListRequestsClusterBranchingContext provides the cluster-branching list-requests action context.
type ListRequestsClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	State       *string
	ToTime      *int
	Type        *string
}

// NewListRequestsClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-requests action.
func NewListRequestsClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListRequestsClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListRequestsClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp26 := fromTime
			tmp25 := &tmp26
			rctx.FromTime = tmp25
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp29 := skip
			tmp28 := &tmp29
			rctx.Skip = tmp28
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramState := req.Params["state"]
	if len(paramState) > 0 {
		rawState := paramState[0]
		rctx.State = &rawState
		if rctx.State != nil {
			if !(*rctx.State == "running" || *rctx.State == "finish_successfully" || *rctx.State == "failed") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`state`, *rctx.State, []interface{}{"running", "finish_successfully", "failed"}))
			}
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp31 := toTime
			tmp30 := &tmp31
			rctx.ToTime = tmp30
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "create_branch" || *rctx.Type == "update_branch" || *rctx.Type == "extend_expration" || *rctx.Type == "expire_now") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"create_branch", "update_branch", "extend_expration", "expire_now"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListRequestsClusterBranchingContext) OK(r *CountableCollectionRequests) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-requests+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ListSnapshotBranchesClusterBranchingContext provides the cluster-branching list-snapshot-branches action context.
type ListSnapshotBranchesClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	FromTime   *int
	Limit      int
	Requestor  *string
	Skip       *int
	SnapshotID string
	Status     *string
	Team       *string
	ToTime     *int
	Type       *string
}

// NewListSnapshotBranchesClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-snapshot-branches action.
func NewListSnapshotBranchesClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListSnapshotBranchesClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListSnapshotBranchesClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp33 := fromTime
			tmp32 := &tmp33
			rctx.FromTime = tmp32
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp36 := skip
			tmp35 := &tmp36
			rctx.Skip = tmp35
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramSnapshotID := req.Params["snapshot_id"]
	if len(paramSnapshotID) > 0 {
		rawSnapshotID := paramSnapshotID[0]
		rctx.SnapshotID = rawSnapshotID
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp38 := toTime
			tmp37 := &tmp38
			rctx.ToTime = tmp37
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListSnapshotBranchesClusterBranchingContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListSnapshotBranchesClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListSnapshotsClusterBranchingContext provides the cluster-branching list-snapshots action context.
type ListSnapshotsClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Skip        *int
	ToTime      *int
}

// NewListSnapshotsClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller list-snapshots action.
func NewListSnapshotsClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListSnapshotsClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListSnapshotsClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp40 := fromTime
			tmp39 := &tmp40
			rctx.FromTime = tmp39
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp43 := skip
			tmp42 := &tmp43
			rctx.Skip = tmp42
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp45 := toTime
			tmp44 := &tmp45
			rctx.ToTime = tmp44
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListSnapshotsClusterBranchingContext) OK(r *CountableCollectionClusterSnapshots) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-snapshots+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowBrancheClusterBranchingContext provides the cluster-branching show-branche action context.
type ShowBrancheClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	BranchID string
}

// NewShowBrancheClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-branche action.
func NewShowBrancheClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowBrancheClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowBrancheClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramBranchID := req.Params["branch_id"]
	if len(paramBranchID) > 0 {
		rawBranchID := paramBranchID[0]
		rctx.BranchID = rawBranchID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowBrancheClusterBranchingContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowBrancheClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowClusterClusterBranchingContext provides the cluster-branching show-cluster action context.
type ShowClusterClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
}

// NewShowClusterClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-cluster action.
func NewShowClusterClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowClusterClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowClusterClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowClusterClusterBranchingContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowClusterClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowRequestClusterBranchingContext provides the cluster-branching show-request action context.
type ShowRequestClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewShowRequestClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-request action.
func NewShowRequestClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowRequestClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowRequestClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowRequestClusterBranchingContext) OK(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowRequestClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ShowRequestTaskClusterBranchingContext provides the cluster-branching show-request-task action context.
type ShowRequestTaskClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewShowRequestTaskClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-request-task action.
func NewShowRequestTaskClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowRequestTaskClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowRequestTaskClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowRequestTaskClusterBranchingContext) OK(r *BranchRequestTask) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowRequestTaskLogClusterBranchingContext provides the cluster-branching show-request-task-log action context.
type ShowRequestTaskLogClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewShowRequestTaskLogClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-request-task-log action.
func NewShowRequestTaskLogClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowRequestTaskLogClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowRequestTaskLogClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowRequestTaskLogClusterBranchingContext) OK(r *BranchRequestTask) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowSnapshotClusterBranchingContext provides the cluster-branching show-snapshot action context.
type ShowSnapshotClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	SnapshotID string
}

// NewShowSnapshotClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller show-snapshot action.
func NewShowSnapshotClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowSnapshotClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowSnapshotClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramSnapshotID := req.Params["snapshot_id"]
	if len(paramSnapshotID) > 0 {
		rawSnapshotID := paramSnapshotID[0]
		rctx.SnapshotID = rawSnapshotID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowSnapshotClusterBranchingContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowSnapshotClusterBranchingContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// SubscribeRequestChangesClusterBranchingContext provides the cluster-branching subscribe-request-changes action context.
type SubscribeRequestChangesClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewSubscribeRequestChangesClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller subscribe-request-changes action.
func NewSubscribeRequestChangesClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*SubscribeRequestChangesClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SubscribeRequestChangesClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// SubscribeRequestTaskLogStreamClusterBranchingContext provides the cluster-branching subscribe-request-task-log-stream action context.
type SubscribeRequestTaskLogStreamClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewSubscribeRequestTaskLogStreamClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller subscribe-request-task-log-stream action.
func NewSubscribeRequestTaskLogStreamClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*SubscribeRequestTaskLogStreamClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SubscribeRequestTaskLogStreamClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// UpdateBranchClusterBranchingContext provides the cluster-branching update-branch action context.
type UpdateBranchClusterBranchingContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UpdateBranchPayload
}

// NewUpdateBranchClusterBranchingContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branching controller update-branch action.
func NewUpdateBranchClusterBranchingContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateBranchClusterBranchingContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateBranchClusterBranchingContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *UpdateBranchClusterBranchingContext) Accepted(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 202, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateBranchClusterBranchingContext) BadRequest() error {
	ctx.ResponseData.WriteHeader(400)
	return nil
}

// UnprocessableEntity sends a HTTP response with status code 422.
func (ctx *UpdateBranchClusterBranchingContext) UnprocessableEntity() error {
	ctx.ResponseData.WriteHeader(422)
	return nil
}
