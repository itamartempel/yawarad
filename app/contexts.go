// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "yawarad": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/itamartempel/yawarad/design
// --out=$(GOPATH)/src/github.com/itamartempel/yawarad
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
)

// CreateBrancheContext provides the branche create action context.
type CreateBrancheContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateBranchPayload
}

// NewCreateBrancheContext parses the incoming request URL and body, performs validations and creates the
// context used by the branche controller create action.
func NewCreateBrancheContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateBrancheContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateBrancheContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateBrancheContext) Created(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateBrancheContext) BadRequest() error {
	ctx.ResponseData.WriteHeader(400)
	return nil
}

// UnprocessableEntity sends a HTTP response with status code 422.
func (ctx *CreateBrancheContext) UnprocessableEntity() error {
	ctx.ResponseData.WriteHeader(422)
	return nil
}

// ListBrancheContext provides the branche list action context.
type ListBrancheContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	Status      *string
	Team        *string
	ToTime      *int
	Type        *string
}

// NewListBrancheContext parses the incoming request URL and body, performs validations and creates the
// context used by the branche controller list action.
func NewListBrancheContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListBrancheContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListBrancheContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp2 := fromTime
			tmp1 := &tmp2
			rctx.FromTime = tmp1
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp5 := skip
			tmp4 := &tmp5
			rctx.Skip = tmp4
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp7 := toTime
			tmp6 := &tmp7
			rctx.ToTime = tmp6
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListBrancheContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowBrancheContext provides the branche show action context.
type ShowBrancheContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	BranchID string
}

// NewShowBrancheContext parses the incoming request URL and body, performs validations and creates the
// context used by the branche controller show action.
func NewShowBrancheContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowBrancheContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowBrancheContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramBranchID := req.Params["branch_id"]
	if len(paramBranchID) > 0 {
		rawBranchID := paramBranchID[0]
		rctx.BranchID = rawBranchID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowBrancheContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowBrancheContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// UpdateBrancheContext provides the branche update action context.
type UpdateBrancheContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *UpdateBranchPayload
}

// NewUpdateBrancheContext parses the incoming request URL and body, performs validations and creates the
// context used by the branche controller update action.
func NewUpdateBrancheContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateBrancheContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateBrancheContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *UpdateBrancheContext) Accepted(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 202, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateBrancheContext) BadRequest() error {
	ctx.ResponseData.WriteHeader(400)
	return nil
}

// UnprocessableEntity sends a HTTP response with status code 422.
func (ctx *UpdateBrancheContext) UnprocessableEntity() error {
	ctx.ResponseData.WriteHeader(422)
	return nil
}

// ListClusterContext provides the cluster list action context.
type ListClusterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	ClusterType *string
	Limit       int
	Skip        *int
}

// NewListClusterContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster controller list action.
func NewListClusterContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClusterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClusterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramClusterType := req.Params["cluster_type"]
	if len(paramClusterType) > 0 {
		rawClusterType := paramClusterType[0]
		rctx.ClusterType = &rawClusterType
		if rctx.ClusterType != nil {
			if !(*rctx.ClusterType == "mysql" || *rctx.ClusterType == "mongodb") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`cluster_type`, *rctx.ClusterType, []interface{}{"mysql", "mongodb"}))
			}
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp10 := skip
			tmp9 := &tmp10
			rctx.Skip = tmp9
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClusterContext) OK(r *CountableCollectionClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowClusterContext provides the cluster show action context.
type ShowClusterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
}

// NewShowClusterContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster controller show action.
func NewShowClusterContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowClusterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowClusterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowClusterContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowClusterContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListClusterBranchesContext provides the cluster-branches list action context.
type ListClusterBranchesContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	Status      *string
	Team        *string
	ToTime      *int
	Type        *string
}

// NewListClusterBranchesContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-branches controller list action.
func NewListClusterBranchesContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClusterBranchesContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClusterBranchesContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp12 := fromTime
			tmp11 := &tmp12
			rctx.FromTime = tmp11
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp15 := skip
			tmp14 := &tmp15
			rctx.Skip = tmp14
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp17 := toTime
			tmp16 := &tmp17
			rctx.ToTime = tmp16
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClusterBranchesContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListClusterBranchesContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListClusterSnapshotsContext provides the cluster-snapshots list action context.
type ListClusterSnapshotsContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName string
	FromTime    *int
	Limit       int
	Skip        *int
	ToTime      *int
}

// NewListClusterSnapshotsContext parses the incoming request URL and body, performs validations and creates the
// context used by the cluster-snapshots controller list action.
func NewListClusterSnapshotsContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListClusterSnapshotsContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListClusterSnapshotsContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp19 := fromTime
			tmp18 := &tmp19
			rctx.FromTime = tmp18
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp22 := skip
			tmp21 := &tmp22
			rctx.Skip = tmp21
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp24 := toTime
			tmp23 := &tmp24
			rctx.ToTime = tmp23
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListClusterSnapshotsContext) OK(r *CountableCollectionClusterSnapshots) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-snapshots+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListClusterSnapshotsContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListRequestContext provides the request list action context.
type ListRequestContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Requestor   *string
	Skip        *int
	State       *string
	ToTime      *int
	Type        *string
}

// NewListRequestContext parses the incoming request URL and body, performs validations and creates the
// context used by the request controller list action.
func NewListRequestContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListRequestContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListRequestContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp26 := fromTime
			tmp25 := &tmp26
			rctx.FromTime = tmp25
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp29 := skip
			tmp28 := &tmp29
			rctx.Skip = tmp28
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramState := req.Params["state"]
	if len(paramState) > 0 {
		rawState := paramState[0]
		rctx.State = &rawState
		if rctx.State != nil {
			if !(*rctx.State == "running" || *rctx.State == "finish_successfully" || *rctx.State == "failed") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`state`, *rctx.State, []interface{}{"running", "finish_successfully", "failed"}))
			}
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp31 := toTime
			tmp30 := &tmp31
			rctx.ToTime = tmp30
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "create_branch" || *rctx.Type == "update_branch" || *rctx.Type == "extend_expration" || *rctx.Type == "expire_now") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"create_branch", "update_branch", "extend_expration", "expire_now"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListRequestContext) OK(r *CountableCollectionRequests) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-requests+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowRequestContext provides the request show action context.
type ShowRequestContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewShowRequestContext parses the incoming request URL and body, performs validations and creates the
// context used by the request controller show action.
func NewShowRequestContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowRequestContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowRequestContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowRequestContext) OK(r *BranchRequest) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowRequestContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// SubscribeRequestChangesContext provides the request-changes subscribe action context.
type SubscribeRequestChangesContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewSubscribeRequestChangesContext parses the incoming request URL and body, performs validations and creates the
// context used by the request-changes controller subscribe action.
func NewSubscribeRequestChangesContext(ctx context.Context, r *http.Request, service *goa.Service) (*SubscribeRequestChangesContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SubscribeRequestChangesContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// ListRequestTaskContext provides the request-task list action context.
type ListRequestTaskContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
}

// NewListRequestTaskContext parses the incoming request URL and body, performs validations and creates the
// context used by the request-task controller list action.
func NewListRequestTaskContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListRequestTaskContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListRequestTaskContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListRequestTaskContext) OK(r BranchRequestTaskCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json; type=collection")
	}
	if r == nil {
		r = BranchRequestTaskCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// LogRequestTaskContext provides the request-task log action context.
type LogRequestTaskContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewLogRequestTaskContext parses the incoming request URL and body, performs validations and creates the
// context used by the request-task controller log action.
func NewLogRequestTaskContext(ctx context.Context, r *http.Request, service *goa.Service) (*LogRequestTaskContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := LogRequestTaskContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *LogRequestTaskContext) OK(r *BranchRequestTask) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowRequestTaskContext provides the request-task show action context.
type ShowRequestTaskContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewShowRequestTaskContext parses the incoming request URL and body, performs validations and creates the
// context used by the request-task controller show action.
func NewShowRequestTaskContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowRequestTaskContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowRequestTaskContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowRequestTaskContext) OK(r *BranchRequestTask) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.branch-request-task+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// StreamLogRequestTaskContext provides the request-task stream-log action context.
type StreamLogRequestTaskContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	RequestID string
	TaskName  string
}

// NewStreamLogRequestTaskContext parses the incoming request URL and body, performs validations and creates the
// context used by the request-task controller stream-log action.
func NewStreamLogRequestTaskContext(ctx context.Context, r *http.Request, service *goa.Service) (*StreamLogRequestTaskContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StreamLogRequestTaskContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramRequestID := req.Params["request_id"]
	if len(paramRequestID) > 0 {
		rawRequestID := paramRequestID[0]
		rctx.RequestID = rawRequestID
	}
	paramTaskName := req.Params["task_name"]
	if len(paramTaskName) > 0 {
		rawTaskName := paramTaskName[0]
		rctx.TaskName = rawTaskName
	}
	return &rctx, err
}

// ListSnapshotContext provides the snapshot list action context.
type ListSnapshotContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ClusterName *string
	FromTime    *int
	Limit       int
	Skip        *int
	ToTime      *int
}

// NewListSnapshotContext parses the incoming request URL and body, performs validations and creates the
// context used by the snapshot controller list action.
func NewListSnapshotContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListSnapshotContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListSnapshotContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramClusterName := req.Params["cluster_name"]
	if len(paramClusterName) > 0 {
		rawClusterName := paramClusterName[0]
		rctx.ClusterName = &rawClusterName
	}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp33 := fromTime
			tmp32 := &tmp33
			rctx.FromTime = tmp32
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp36 := skip
			tmp35 := &tmp36
			rctx.Skip = tmp35
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp38 := toTime
			tmp37 := &tmp38
			rctx.ToTime = tmp37
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListSnapshotContext) OK(r *CountableCollectionClusterSnapshots) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-snapshots+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// ShowSnapshotContext provides the snapshot show action context.
type ShowSnapshotContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	SnapshotID string
}

// NewShowSnapshotContext parses the incoming request URL and body, performs validations and creates the
// context used by the snapshot controller show action.
func NewShowSnapshotContext(ctx context.Context, r *http.Request, service *goa.Service) (*ShowSnapshotContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ShowSnapshotContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramSnapshotID := req.Params["snapshot_id"]
	if len(paramSnapshotID) > 0 {
		rawSnapshotID := paramSnapshotID[0]
		rctx.SnapshotID = rawSnapshotID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ShowSnapshotContext) OK(r *ClusterForBranching) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.cluster-for-branching+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ShowSnapshotContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListSnapshotBranchesContext provides the snapshot-branches list action context.
type ListSnapshotBranchesContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	FromTime   *int
	Limit      int
	Requestor  *string
	Skip       *int
	SnapshotID string
	Status     *string
	Team       *string
	ToTime     *int
	Type       *string
}

// NewListSnapshotBranchesContext parses the incoming request URL and body, performs validations and creates the
// context used by the snapshot-branches controller list action.
func NewListSnapshotBranchesContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListSnapshotBranchesContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListSnapshotBranchesContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramFromTime := req.Params["from_time"]
	if len(paramFromTime) > 0 {
		rawFromTime := paramFromTime[0]
		if fromTime, err2 := strconv.Atoi(rawFromTime); err2 == nil {
			tmp40 := fromTime
			tmp39 := &tmp40
			rctx.FromTime = tmp39
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("from_time", rawFromTime, "integer"))
		}
	}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 100
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 100, false))
		}
	}
	paramRequestor := req.Params["requestor"]
	if len(paramRequestor) > 0 {
		rawRequestor := paramRequestor[0]
		rctx.Requestor = &rawRequestor
	}
	paramSkip := req.Params["skip"]
	if len(paramSkip) > 0 {
		rawSkip := paramSkip[0]
		if skip, err2 := strconv.Atoi(rawSkip); err2 == nil {
			tmp43 := skip
			tmp42 := &tmp43
			rctx.Skip = tmp42
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("skip", rawSkip, "integer"))
		}
	}
	paramSnapshotID := req.Params["snapshot_id"]
	if len(paramSnapshotID) > 0 {
		rawSnapshotID := paramSnapshotID[0]
		rctx.SnapshotID = rawSnapshotID
	}
	paramStatus := req.Params["status"]
	if len(paramStatus) > 0 {
		rawStatus := paramStatus[0]
		rctx.Status = &rawStatus
		if rctx.Status != nil {
			if !(*rctx.Status == "creating" || *rctx.Status == "updateing" || *rctx.Status == "active" || *rctx.Status == "grace" || *rctx.Status == "expired" || *rctx.Status == "deleted") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`status`, *rctx.Status, []interface{}{"creating", "updateing", "active", "grace", "expired", "deleted"}))
			}
		}
	}
	paramTeam := req.Params["team"]
	if len(paramTeam) > 0 {
		rawTeam := paramTeam[0]
		rctx.Team = &rawTeam
	}
	paramToTime := req.Params["to_time"]
	if len(paramToTime) > 0 {
		rawToTime := paramToTime[0]
		if toTime, err2 := strconv.Atoi(rawToTime); err2 == nil {
			tmp45 := toTime
			tmp44 := &tmp45
			rctx.ToTime = tmp44
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("to_time", rawToTime, "integer"))
		}
	}
	paramType := req.Params["type"]
	if len(paramType) > 0 {
		rawType := paramType[0]
		rctx.Type = &rawType
		if rctx.Type != nil {
			if !(*rctx.Type == "dev" || *rctx.Type == "dr") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type`, *rctx.Type, []interface{}{"dev", "dr"}))
			}
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListSnapshotBranchesContext) OK(r *CountableCollectionClusterBranches) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.countable-collection-cluster-branches+json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListSnapshotBranchesContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}
